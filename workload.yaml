# We call a set of workloads that should be executed together, an I/O scenario.
io_scenario:
  # Range: {SYNTHETIC, TRACE}
  - type: SYNTHETIC
    setup:
      # the priority class of the I/O queue associated with this I/O request. 
      # Range = {URGENT, HIGH, MEDIUM, LOW}.
      priority_class: HIGH
      # the type of on-device data caching for this flow.
      # Range={WRITE_CACHE, READ_CACHE, WRITE_READ_CACHE, TURNED_OFF}. 
      # If the caching mechanism mentioned above is set to SIMPLE, 
      # then only WRITE_CACHE and TURNED_OFF modes could be used.
      device_level_data_caching_mode: WRITE_CACHE
      # a comma-separated list of channel IDs that are allocated to this workload. 
      # This list is used for resource partitioning. If there are C channels in 
      # the SSD (defined in the SSD configuration file), then the channel ID list 
      # should include values in the range 0 to C-1. If no resource partitioning 
      # is required, then all workloads should have channel IDs 0 to C-1.
      channel_ids: [0, 1, 2, 3, 4, 5, 6, 7]
      # a comma-separated list of chip IDs that are allocated to this workload. 
      # This list is used for resource partitioning. If there are W chips in each 
      # channel (defined in the SSD configuration file), then the chip ID list 
      # should include values in the range 0 to W-1. If no resource partitioning 
      # is required, then all workloads should have chip IDs 0 to W-1.
      chip_ids: [0, 1, 2, 3]
      # a comma-separated list of chip IDs that are allocated to this workload. 
      # This list is used for resource partitioning. If there are D dies in each 
      # flash chip (defined in the SSD configuration file), then the die ID list 
      # should include values in the range 0 to D-1. If no resource partitioning 
      # is required, then all workloads should have die IDs 0 to D-1.
      die_ids: [0, 1]
      # a comma-separated list of plane IDs that are allocated to this workload. 
      # This list is used for resource partitioning. If there are P planes in 
      # each die (defined in the SSD configuration file), then the plane ID list 
      # should include values in the range 0 to P-1. If no resource partitioning 
      # is required, then all workloads should have plane IDs 0 to P-1.
      plane_ids: [0, 1]
      # the percentage of the storage space (i.e., logical pages) that is filled 
      # during preconditioning. 
      # Range = {all integer values in the range 1 to 100}.
      initial_occupancy_percentage: 75
      # the percentage of available logical storage space that is accessed by 
      # generated requests. Range = {all integer values in the range 1 to 100}.
      working_set_percentage: 50
      # determines the way that the stream of requests is generated. Currently, 
      # there are two modes for generating consecutive requests, 1) based on the 
      # average bandwidth of I/O requests, or 2) based on the average depth of 
      # the I/O queue. Range = {BANDWIDTH, QUEUE_DEPTH}.
      synthetic_generator_type: QUEUE_DEPTH
      # the ratio of read requests in the generated flow of I/O requests. 
      # Range = {all integer values in the range 1 to 100}.
      read_percentage: 0
      # the distribution pattern of addresses in the generated flow of I/O 
      # requests. 
      # Range = {STREAMING, RANDOM_UNIFORM, RANDOM_HOTCOLD, MIXED_STREAMING_RANDOM}.
      address_distribution: RANDOM_UNIFORM
      # if RANDOM_HOTCOLD is set for address distribution, then this parameter 
      # determines the ratio of the hot region with respect to the entire logical 
      # address space. Range = {all integer values in the range 1 to 100}.
      percentage_of_hot_region: 0
      # the toggle to enable aligned address generation. Range = {true, false}.
      generated_aligned_addresses: true
      # the unit that all generated addresses must be aligned to in sectors 
      # (i.e. 512 bytes). Range = {all positive integer values}.
      address_alignment_unit: 16
      # the distribution pattern of request sizes in the generated flow of I/O 
      # requests. Range = {FIXED, NORMAL}.
      request_size_distribution: FIXED
      # average size of generated I/O requests in sectors (i.e. 512 bytes). 
      # Range = {all positive integer values}.
      avg_req_size: 8
      # if the request size distribution is set to NORMAL, then this parameter 
      # determines the variance of I/O request sizes in sectors. 
      # Range = {all non-negative integer values}.
      variance_req_size: 0
      # the seed value that is used for random number generation. 
      # Range = {all positive integer values}.
      seed: 798
      # average number of I/O requests enqueued in the host-side I/O queue 
      # (i.e., the intensity of the generated flow). This parameter is used 
      # in QUEUE_DEPTH mode of request generation. 
      # Range = {all positive integer values}.
      avg_num_reqs_in_queue: 16
      # MQSim does not use this. Why does this parameter exist?
      intensity: 32768
      # defines when to stop generating I/O requests in nanoseconds.
      stop_time: 10000000000
      # if Stop_Time is set to zero, then MQSim's request generator considers 
      # Total_Requests_To_Generate to decide when to stop generating I/O requests.
      total_reqs_to_generate: 0
      # the average bandwidth of I/O requests (i.e., the intensity of the 
      # generated flow) in bytes per seconds. MQSim uses this parameter in 
      # BANDWIDTH mode of request generation.
      # is 0 correct?
      bandwidth: 0
  # Range: {SYNTHETIC, TRACE}
  - type: SYNTHETIC
    setup:
      # the priority class of the I/O queue associated with this I/O request. 
      # Range = {URGENT, HIGH, MEDIUM, LOW}.
      priority_class: HIGH
      # the type of on-device data caching for this flow.
      # Range={WRITE_CACHE, READ_CACHE, WRITE_READ_CACHE, TURNED_OFF}. 
      # If the caching mechanism mentioned above is set to SIMPLE, 
      # then only WRITE_CACHE and TURNED_OFF modes could be used.
      device_level_data_caching_mode: WRITE_CACHE
      # a comma-separated list of channel IDs that are allocated to this workload. 
      # This list is used for resource partitioning. If there are C channels in 
      # the SSD (defined in the SSD configuration file), then the channel ID list 
      # should include values in the range 0 to C-1. If no resource partitioning 
      # is required, then all workloads should have channel IDs 0 to C-1.
      channel_ids: [0, 1, 2, 3, 4, 5, 6, 7]
      # a comma-separated list of chip IDs that are allocated to this workload. 
      # This list is used for resource partitioning. If there are W chips in each 
      # channel (defined in the SSD configuration file), then the chip ID list 
      # should include values in the range 0 to W-1. If no resource partitioning 
      # is required, then all workloads should have chip IDs 0 to W-1.
      chip_ids: [0, 1, 2, 3]
      # a comma-separated list of chip IDs that are allocated to this workload. 
      # This list is used for resource partitioning. If there are D dies in each 
      # flash chip (defined in the SSD configuration file), then the die ID list 
      # should include values in the range 0 to D-1. If no resource partitioning 
      # is required, then all workloads should have die IDs 0 to D-1.
      die_ids: [0, 1]
      # a comma-separated list of plane IDs that are allocated to this workload. 
      # This list is used for resource partitioning. If there are P planes in 
      # each die (defined in the SSD configuration file), then the plane ID list 
      # should include values in the range 0 to P-1. If no resource partitioning 
      # is required, then all workloads should have plane IDs 0 to P-1.
      plane_ids: [0, 1]
      # the percentage of the storage space (i.e., logical pages) that is filled 
      # during preconditioning. 
      # Range = {all integer values in the range 1 to 100}.
      initial_occupancy_percentage: 75
      # the percentage of available logical storage space that is accessed by 
      # generated requests. Range = {all integer values in the range 1 to 100}.
      working_set_percentage: 50
      # determines the way that the stream of requests is generated. Currently, 
      # there are two modes for generating consecutive requests, 1) based on the 
      # average bandwidth of I/O requests, or 2) based on the average depth of 
      # the I/O queue. Range = {BANDWIDTH, QUEUE_DEPTH}.
      synthetic_generator_type: QUEUE_DEPTH
      # the ratio of read requests in the generated flow of I/O requests. 
      # Range = {all integer values in the range 1 to 100}.
      read_percentage: 0
      # the distribution pattern of addresses in the generated flow of I/O 
      # requests. 
      # Range = {STREAMING, RANDOM_UNIFORM, RANDOM_HOTCOLD, MIXED_STREAMING_RANDOM}.
      address_distribution: RANDOM_UNIFORM
      # if RANDOM_HOTCOLD is set for address distribution, then this parameter 
      # determines the ratio of the hot region with respect to the entire logical 
      # address space. Range = {all integer values in the range 1 to 100}.
      percentage_of_hot_region: 0
      # the toggle to enable aligned address generation. Range = {true, false}.
      generated_aligned_addresses: true
      # the unit that all generated addresses must be aligned to in sectors 
      # (i.e. 512 bytes). Range = {all positive integer values}.
      address_alignment_unit: 16
      # the distribution pattern of request sizes in the generated flow of I/O 
      # requests. Range = {FIXED, NORMAL}.
      request_size_distribution: FIXED
      # average size of generated I/O requests in sectors (i.e. 512 bytes). 
      # Range = {all positive integer values}.
      avg_req_size: 8
      # if the request size distribution is set to NORMAL, then this parameter 
      # determines the variance of I/O request sizes in sectors. 
      # Range = {all non-negative integer values}.
      variance_req_size: 0
      # the seed value that is used for random number generation. 
      # Range = {all positive integer values}.
      seed: 798
      # average number of I/O requests enqueued in the host-side I/O queue 
      # (i.e., the intensity of the generated flow). This parameter is used 
      # in QUEUE_DEPTH mode of request generation. 
      # Range = {all positive integer values}.
      avg_num_reqs_in_queue: 16
      # MQSim does not use this. Why does this parameter exist?
      intensity: 32768
      # defines when to stop generating I/O requests in nanoseconds.
      stop_time: 10000000000
      # if Stop_Time is set to zero, then MQSim's request generator considers 
      # Total_Requests_To_Generate to decide when to stop generating I/O requests.
      total_reqs_to_generate: 0
      # the average bandwidth of I/O requests (i.e., the intensity of the 
      # generated flow) in bytes per seconds. MQSim uses this parameter in 
      # BANDWIDTH mode of request generation.
      # is 0 correct?
      bandwidth: 0

